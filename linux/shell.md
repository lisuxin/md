[toc]

# shell



## shell概念

**shell 的作用是**

* 解释执行用户输入的命令或程序等
* 用户输入一条命令， shell 就解释一条
* 键盘输入命令，Linux 给与响应的方式，称之为交互式
* shell 是一块包裹着系统核心的壳，处于操作系统的最外层，与用户直接对话，把用户的输入，解释给操作系统，然后处理操作系统的输出结果，输出到屏幕给与用户看到结果。
* 从我们登录 Linux ，输入账号密码到进入 Linux 交互式界面，所有的操作，都是交给 shell 解释并执行

**什么是 shell 脚本**：可以吧复杂的命令执行过程，通过逻辑代码，组成一个脚本文件，再去执行该文件就好了

* shell 脚本语言属于一种弱类型语言无需声明变量类型，直接定义使用
* 当命令或者程序语句写在文件中，我们执行文件，读取其中的代码，这个程序文件就称之为 shell 脚本。
* 在 shell 脚本里定义多条 Linux 命令以及循环控制语句，然后将这些 Linux 命令一次性执行完毕，执行脚本文件的方式称之为，非交互式方式。
  * windows 中存在，`.bat` 批处理脚本
  * Linux 中常用，`.sh` 脚本文件
* shell 脚本规则
  * 在 Linux 系统中， shell 脚本或者称之为（ bash shell 程序）通常都是 vim 编辑，由 Linux 命令、 bash shell 指令、逻辑控制语句和注释信息组成。

### Shebang的正确玩法

计算机程序中，shebang 指的是出现在文本文件的第一行前两个字符`#!`

在 Linux 仅系统中，程序会分析 shebang 后面的内容，作为解释器的指令

* 在所有shell脚本前，第一行都必须加上这个`#!`，后面跟解释器地址，是告诉系统此文件使用什么解析器解释编译

* 例如

  * 以 `#! /bin/sh` 开头的文件，程序在执行的时候会调用 `/bin/ sh` ，也就是 bash 解释器
  * 以 `#! /usr/bin/python` 开头的文件，代表指定 python 解释器去执行
  * 以 `#! /usr/bin/env` 解释器名称，是一种在不同平台上都能正确找到解释器的办法

* 注意事项

  * 如果脚本未指定 shebang ，脚本执行的时候，默认用当前 shell 去解释脚本，即 `$SHELL`
  * 如果 shebang 指定了可执行的解释器，如 `/bin/bash /usr/bin/python` ，脚本在执行时，文件名会作为数传递给解释器
  * 如果`#!` 指定的解释程序没有可执行权限，则会报错"bad interpreter ： Permission denied ”。
  * 如果 `#!`指定的解释程序不是一个可执行文件，那么指定的解释程序会被忽略，转而交给当前的 SHELL 去执行这个本
  * 如果 `#!`指定的解释程序不存在，那么会报错“ bad interpreter: No such file or directory ”。
  * `#!`之后的解释程序，需要写其绝对路径（如：`#!/bin/bash` ），它是不会自动到`$PATH` 中寻找解释器的。
  * 如果你使用 `bash test.sh` 这样的命令来执行脚本，那么#！这一行将会被忽略掉，解释器当然是用命令行中显式指定的 bash 。

* 示例

  ```shell
  #! /bin/sh # 这里是指定解释器
  echo "aaa" # 执行的操作
  #!/bin/sh 这里就是注释
  ```

* 执行 shell 脚本的方式

  * `bash scrip.sh`或`sh script.sh`文件本身没权限执行，没 x 权限，则使用的方法，或脚本未指定 shebang，重点推荐的方式
  * 使用`绝对/相对`路径执行本，需要文件含有 x 权限
  * `source script.sh` 或者`．script.sh`代表`执行的含义,source 等于点．`
  * 少见的用法，`sh < script.sh`
  * ==不同的执行方式，不同的 shell 环境==
    1. 每次调用 `bash /sh `解释器执行脚本，都会开启一个子 shell 环境，因此不保留当前的 shell 环境变量，通过`pstree`命令检查进程树
    2. 调用 `source` 或者点`.`符号，是在当前 shell 环境加载脚本。
    3. 开启子shell环境，那么必须使用exit退出子shell环境，才能上层shell环境，否则就会一直存在与子shell环境

### Bash特性

* bash 是一个命令处理器，运行在文本窗囗中，并能执行用户直接输入的命令

* bash 还能从文件中读取 Linxu 命令，称之为脚本

* bash 支持通配符、管道、命令替换，条件判断等逻辑控制语句

* Shell 会保留其会话中用户提交执行的命令

  ```shell
  history # #命令，查看历史命令记录，注意[包含文件中和内存中的历史记录],写在命令行
  
  echo $HISTSIZE # shell 进程可保留的命令历史的条数
  
  ls -a ~/.bash_history # 存放历史命令的文件
  ```

* history

  ```shell
  history # 命令 及参数
  -c # 清空内存中的历史命令
  -r # 从文件中恢复历史命令
  数字 # 显示最近n条命令 history 10
  ```

* 调用历史命令

  ```shell
  !历史id号 # 执行命令
  !! # 执行上条命令
  ```

* 特性

  * 文件路径 tab 键补全
  * 命令补全
  * 快捷键ctrl+a,e,u,k,l
  * 通配符
  * 历史命令
  * 命令别名
  * 命令行展开
  
* 符号

  * `\`：转义符，还原符号，原本的意思，不会被阅读为特殊含义

  * `“”`：当你将一段文本放在双引号中时，Shell会解释这之中的大多数特殊字符，但不会解释其中的变量、命令替换以及反斜杠（\）转义字符。这意味着在双引号内的变量名会被它们的值所替换，而且反斜杠用于转义特定字符（例如，\n表示换行）。

    ```shell
    name="world"
    echo "Hello $name"
    # 结果
    Hello $name
    ```

  * `‘’`：单引号里面的文本不做任何转义

* 就是可以从命令的执行结果中，再提取结果

  * `$()`：再括号中执行命令，且拿到命令的执行结果
  * ``：反引号：再反引号中执行命令，且拿到命令的执行结果

### Linux特殊符号

>${}：在中间加入变量名`${vars}`取出变量结果
>
>$()：再括号中执行命令，且拿到命令的执行结果
>
>``：再反引号中执行命令，且拿到命令的执行结果
>
>()：开启子 shell 执行命令结果
>
>$vars：取出变量结果

## Shell变量

**定义**

* `变量名="值"`：变量与值之间不能有空格

  * 单引号变量，不识别特殊语法

  * 双引号变量，能识别特殊符号

  * 反引号：将变量值，执行的结果赋值给变量名

    ```shell
    [root@localhost ~]# name=`ll`
    [root@localhost ~]# echo $name
    total 20 -rw-------. 1 root root 2809 Dec 23 08:52 anaconda-ks.cfg -rw-r--r-- 1 root root 11320 Jul 25 2023 mysql80-community-release-el7-8.noarch.rpm -rw-------. 1 root root 2127 Dec 23 08:52 original-ks.cfg
    ```

* 调用变量`$变量名`或者`${变量名}`

  * 对变量值的获取，一定加上美元符号，否则就错误了

* 变量类型， bash 默认把所有变量都认为是字符串

**变量名命名规则**

* 名称定义要做到见名知意，切按照规则来，切不得引用保留关键字（ help 检查保留字）
* 只能包含数字、字母、下划线
* 不能以数字开头
* 不能用标点符号
* 变量名严格区分大小写

**变量的作用域**

* 本地变量，只对当前的 shell 进程

  ```shell
  pstree # 检查进程树
  ```

* 环境变量，也称为全局变量，针对当前 shell 以及其任意子进程，环变量也分`自定义、内置`两种环境变量

* 局部变量，针对在` shell 函数`或是 `shell 脚本`中定义

* 位置参数变量：用于 `shell 脚本`中传递的参数

* 特殊变量： shell 内置的特殊功效变量

  * `$?`
    * 0：成功
    * 1-255：失败
    * `echo $?`：判断上一条命令是否执行成功

* 自定义变量

  * 变量赋值：`varName=vaIue`

  * 变量引用：`${varName}、$varName`

  * 双引号，==变量名会替换为变量值==

  * 单引号，识别为普通字符串

    ```shell
    [root@localhost ~]# n1=1
    [root@localhost ~]# n2=2
    [root@localhost ~]# 
    [root@localhost ~]# n3="$n1"
    [root@localhost ~]# echo $n3
    1
    [root@localhost ~]# n4='$n2'
    [root@localhost ~]# echo $n4
    $n2
    ```

* 反引号：将变量值，执行的结果赋值给变量名

### 环境变量设置

==环境变量一般指的是用 export 内置命令导出的变量，用于定义 shell 的运行环境、保证 shell 命令的正确执行==

shell 通过环境变量确定登录的用户名、 PATH 路径、文件系统等各种应用。

环境变量可以在命令行中临时创建，但是用户退出 shell 终端，变量即丢失，如要永久生效，需要修改`环境变量配置文件`

* 用户个人配置文件 `~/.bash-profile` 、`～/.bashrc` 远程登录用户特有文件
  * 环境变量以当前登录用户的配置文件优先生效
* 全局配置文件 `/etc/profile`、`/etc/bashrc`且系统建议最好创建在 `/etc/profile.d/`，而非直接修改主文件，修改全局配置文件，影响所有登录系统的用户

**检查系统环境变量的命令**

* set：输出所有变量，包括全局变量、局部变量
* env：只显示全局变量
* declare：输出所有的变量，如同 set
* export：显示和设置环境变量值

**撤销环境变量**

* `unset 变量名`，删除变量或函数。

**设置只读变量**

* readonly ，只有 shell 结束，只读变量失效：`readonly password="132"`
* 直接readonly显示当前系统只读变量`readonly`

**系统保留环境变量关键字**

* bash 内嵌了诸多环境变量，用于定义 bash 的工作环境

  ```shell
  export | awk -F '[ :=]' '{print $3}'
  ```

**bash 多命令执行**

```shell
ls /data/;cd /tmp/;cd /home;cd /data
```

**环境变量初始化与加载顺序**

![image-20250109002157964](../typoratuxiang/linux/shell1.png)

### shell特殊参数变量

==shell 的特殊变量，用在如脚本，函数传递参数使用，有如下特殊的，位置参数变量==

* `$0`：获取 shell 脚本文件名，以及脚本路径
* `$n`：获取 shell 脚本的第 n 个参数，n 在 1~9 之间，如`$1,$2,$9` ，大于 9 则需要写，`${ 10 }`，参数空格隔开
* `$#`：获取执行的 shell 脚本后面的参数总个数
* `$*`：获取 shell 脚本所有参数，不加引号等同于` $@`作 用，加上引号`"$*"`作用是接收所有参数为单个字符串，`"$1 $2 ..`
* `$@`：不加引号，效果同上，加引号，是接收所有参数为独立字符串，如`“$1” "$2" $3 ...`空格保留

**特殊变量实践**

```shell
[root@localhost ~]# sh shijian.sh q w e r t
$0 $1 $2
shijian.sh q w
$#
5
$*
q w e r t
$@
q w e r t
[root@localhost ~]# cat shijian.sh
#! /bin/sh
echo '$0 $1 $2'
echo $0 $1 $2
echo '$#'
echo $#
echo '$*'
echo $*
echo '$@'
echo $@
```

* `$*`和`$@` 都表示传递给函数或脚本的所有参数

* 不被双引号`""`包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。

* 但是当它们被双引号`“”`包含时

  * `$*`：将所有的参数从整体上看做一份数据，而不是吧每个参数都看做一份数据。
  * `$@`：仍然将每个参数都看作一份数据，彼此之间是独立的。

* 可以使用shell的for循环查看

  ```shell
  for var in "$*"
  do
    echo "$var"
  done
  
  for var in "$@"
  do
    echo "$var"
  done
  
  # 开始一个for循环，"$@" 是一个特殊变量，它代表所有传递给脚本或函数的参数。
  # 每次迭代中，$var 将依次被赋予 "$@" 中的每个值（即每个参数）。
  for var in "$@"
  do
    # echo 命令输出 $var 的值到标准输出（通常是终端）。这里的 $var 在每次循环时都会被替换为当前迭代的实际参数值。
    echo "$var"
  done
  ```

  1. **`for var in "$@"`**: 这是循环的开始。`"$@"` 是一个包含所有传递给脚本或函数的位置参数的列表。在双引号内的使用确保了即使参数中包含空格或其他特殊字符也能被正确处理。`var` 是循环变量，在每次循环时被赋值为 `"$@"` 中的一个元素。
  2. **`do`**: 标志着循环体的开始。循环体是指那些需要对 `$@` 中的每个元素执行的命令集合。
  3. **`echo "$var"`**: 在循环体内，`echo` 命令用于输出变量 `$var` 的值。由于 `$var` 在每次迭代中都被赋值为 `"$@"` 列表中的下一个参数，因此这行代码会按顺序打印出所有传入脚本或函数的参数。
  4. **`done`**: 标志着循环体的结束。当到达 `done` 时，如果 `"$@"` 中还有未处理的元素，循环将继续；否则，循环结束，程序继续执行循环后面的命令。

### shell特殊状态变量

* `$?`：上一次命令执行状态返回值， 0 正确，非 0 失败
* `$$`：当前 shell 脚本的进程号
* `$!`：上一次后台进程的 PID
* `$_`：上次执行命令的最后一个参数
* 查找方式`man bash`搜索`/Special Parameters`

**脚本控制返回值**

==这个脚本执行完毕了，会返回一个数字 id ，称之为返回值==

## 内置shell命令

命令使用分号隔开，进行语句结束

* `echo`：打印输出

  * 参数
  * `-n`：不换行输出
  * `-e`：解析字符串中的特殊符号
    * 特殊符号：`\n`：换行；`\r`：回车；`\t`：制表符 四个空格；`\b`：退格

* `printf ""`：打印输出，自动识别特殊符号

* `eval`：执行多个命令

  * 语法`ecal 命令1;命令2;命令3.....`

* `exec`：不创建子进程，执行后续命令，且执行完毕后，自动 exit，退出进程

* `export`：为当前shell及其子shell设置环境变量

  * 语法`export 环境变量名="值"`

* `read`：用于从标准输入（通常是键盘）读取一行数据，并将读取的数据分配给一个或多个shell变量

  * 示例：

    ```bash
    read -p "Enter your name: " NAME
    echo "Hello, $NAME!"
    ```

  * 这段脚本提示用户输入名字，并将输入的名字存储在变量`NAME`中，然后打印一条问候消息。

* `shift`：用于改变位置参数的位置。它使得原本的2变为2变为1，3变为3变为2，以此类推，而原始的$1则被丢弃。这个命令通常用于处理脚本中的命令行参数列表。

  * 示例：

    ```bash
    while [ "$#" -gt 0 ]; do
        echo "Argument $1"
        shift
    done
    ```

  * 这个循环会遍历所有的命令行参数，每次迭代后执行`shift`，使得下一个参数成为1，直到没有参数为止（即‘1，直到没有参数为止（即‘#`变为0）。

### 变量子串的语法

```bash
${变量}                           返回变量值
${#变量}                          返回变量长度,字符串长度
${变量:start}                     返回变量start数值之后的字符,包括start        ${name:4}
${变量:start:length}              提取start之后的length限制的字符
${变量#woed}                      从变量开头删除最短匹配的word子串,            word:值的一部分
${变量##word}                     从变量开头删除最长匹配的word子串
${变量%word}                      从变量从前向后删除最短的word
${变量%%word}                     从变量结尾开始删除最长匹配的word
${变量/pattern/string}            用string代替第一个匹配的pattern
${变量//pattern/string}           用string代替所有的pattern
```

**统计变量子串的长度**

* `wc -L`：统计最长的一行的字符数
* `expr length "$变量名"`：统计字符串的长度
* `awk '{print length($0)}'`：统计一整行
* `${#变量名}`：最快方法

**统计命令执行的时长**

* time命令

  ```bash
  time 命令
  ```

* for循环

  ```bash
  for 变量 in 序列
  do
      在循环中执行的语句
  done
  # 写为一行
  for 变量 in {1..5};do 在循环中执行的语句;done# 循环{1..5}循环5次
  ```

* 统计时间

  ```bash
  time for n in {1..5};do char=`seq -s "qqwe" 100`;echo ${#char} &>/dev/null;done
  
  char=`seq -s "qqwe" 100`;
  # 使用 seq 命令生成一个字符串，并将其赋值给变量 char。让我们拆分这条命令来理解它的含义：
  # `...`：这是反引号，用于命令替换。它会执行其中的命令，并将输出结果替换到当前命令行中。
  # seq -s "qqwe" 100：这里的 seq 命令用来生成数字序列。通常情况下，seq 的基本用法是 seq [选项]... 尾数 或者 seq [选项]... 首数 尾数 [增量] 来生成一系列数字。然而，在这个例子中，通过 -s 参数（separator），指定了数字之间的分隔符为 "qqwe"，并且只提供了一个参数 100，这意味着从 1 开始到 100 结束，默认每个数递增 1。
  ```

* shell编程，尽量使用 linux 内置的命令，内置的操作，和内置的函数，效率最高 c 语言开发，效率最高，尽可能的减少管道符的操作

**批量修改文件名**

* `touch qw_{1..5}_aq.txt`：批量新建文件

* 批量修改

  ```bash
  for n in ls *.txt
  do 
    mv $n echo ${n//_qa/}
  done
  # 一行
  for n in `ls *.txt`;do mv $n `echo ${n//_aq/}`;done
  for n in `ls *.txt`;do mv $n ${n//_aq/};done
  ```

### shell扩展变量

==对变量的值进行判断、处理；res接收值的变量==

* 如果 parameter 变量值为空，返回 word 字符串

* `res=${parameter:-word}`

* 如果 para 变量为空，则 word 替代变量值，且返回其值

* `res=${parameter:=word}`

* 如果 para 变量为空， word 当作 stderr 输出，否则输出变量值；用于设置变量为空导致错误时，返回的错误信息

* `res=${parameter:?word}`

* 如果 para 变量为空，什么都不做，否则(不为空) word 返回

* `res=${parameter:+word}`

  ```shell
  # 删除7天以上数据
  find xargs 搜索，且删除
  find 需要搜索的目录 -name 需要搜索的文件名字 -type 文件类型 -mtime +7|xargs rm -f
  
  # 删除dar_data变量值的目录下的所有 .txt 文档
  find ${dar_data:=/data/ear} -name '*.txt' -type f -mtime +7|xargs rm -f
  ```

### 为什么需要父子shell

* `ps -ef --forest`:检查父子shell的关系
* 创建进程列表：`列表,被包裹起来的数据`
* shell 的进程列表理念，需要使用 `()` 小括号，如下执行方式，就称之为，进程列表
* 加上小括号就是开启子shell环境
* `(cd ~;pwd;ls ;cd /tmp/;pwd;ls)`
* 明确开启子shell命令,就是加上小括号，也可以小括号内进行嵌套小括号

> **进程隔离**

- 独立执行环境：每个 shell（无论是父 shell 还是子 shell）都有自己的执行环境，包括环境变量、工作目录和资源限制等。当在一个子 shell 中运行命令或脚本时，它不会影响父 shell 的环境。这种隔离可以避免意外的副作用。

> **脚本执行**

- 脚本在子 shell 中运行：当你执行一个脚本时，默认情况下它会在一个新的子 shell 中运行。这意味着脚本中的任何对环境变量的更改都不会影响到父 shell。这提供了灵活性，允许你在不影响当前shell会话的情况下测试或执行一系列命令。

- 执行shell脚本的方式

  ```shell
  source   my.sh
  . my.sh
  bash my.sh
  ./mmy.sh
  ```

- 执行 shell 脚本的方式

  * `bash scrip.sh`或`sh script.sh`文件本身没权限执行，没 x 权限，则使用的方法，或脚本未指定 shebang，重点推荐的方式
  * 使用`绝对/相对`路径执行本，需要文件含有 x 权限
  * `source script.sh` 或者`．script.sh`代表`执行的含义,source 等于点．`
  * 少见的用法，`sh < script.sh`
  * ==不同的执行方式，不同的 shell 环境==
    1. 每次调用 `bash /sh `解释器执行脚本，都会开启一个子 shell 环境，因此不保留当前的 shell 环境变量，通过`pstree`命令检查进程树
    2. 调用 `source` 或者点`.`符号，是在当前 shell 环境加载脚本。
    3. 开启子shell环境，那么必须使用exit退出子shell环境，才能上层shell环境，否则就会一直存在与子shell环境
  * 当你用不同的方式，执行脚本，产生的后果也不一样
    * source 和 . 是在当前的 shell 环境中加載变量，执行脚本
    * bash 或 sh 去执行脚本的时候，是开启子 shell 运行的，变量也是在子 shell 环境中加载，子 shell退出后，变量也就消失了

> **并发处理**

- 并行执行任务：通过启动子 shell，可以在后台并发地执行多个任务，从而提高效率。例如，在编写 shell 脚本时，可以通过 `&` 将命令放到后台执行，这些后台命令通常会在子 shell 中运行。

> **继承与定制**

- 继承父 shell 的环境：子 shell 启动时会继承父 shell 的环境变量和其他属性，但这些设置可以被子 shell 自定义或覆盖。这使得可以根据需要调整子环境，而不影响全局设置。

> **资源管理**

- 资源控制：每个 shell 实例都可以看作是一个独立的进程，系统可以根据需要为不同的 shell 分配资源。比如，通过 ulimit 命令可以控制 shell 及其子进程使用的资源量。

### Shell内置、外置命令

> **内置命令**：在系统启动时就加载入内存，常驻内存，执行效率更高，但是占用资源。
>
> * 内置命令不会产生子进程去执行
> * 内置命令和 shell 是为一体的，是 shell 的一部分，不需要单独去读取某个文件，系统启动后，就执行在内存中了
>
> **外置命令**：系统需要从硬盘中读取程序文件，在读入内存加载，外置命令一定会开启一个子进程。

### linux默认有关shell的变量

1. **`$HOME`**：当前用户的家目录路径。
2. **`$PATH`**：可执行文件的搜索路径。当你尝试运行一个命令时，shell 会按照 `$PATH` 中列出的顺序查找这个命令。
3. **`$PWD`**：当前工作目录。
4. **`$OLDPWD`**：之前的工作目录。当你使用 `cd -` 来切换回上一个工作目录时，就是依靠这个变量。
5. **`$SHELL`**：当前用户默认使用的 shell 程序路径。
6. **`$USER`**：当前用户名。
7. **`$UID`**：当前用户的用户ID（UID）。
8. **`$PS1`**：主提示符字符串定义。这是你在命令行看到的提示符样式，默认情况下包含 `\u@\h:\w\$`，分别代表用户名、主机名和当前目录。
9. **`$PS2`**：次提示符字符串，当 shell 需要更多输入来完成命令时显示（比如多行命令）。
10. **`$EDITOR`**：默认文本编辑器。虽然这不是 Bash 默认设置的一个环境变量，但它经常被设置为 `vi`, `vim`, 或 `nano` 等。
11. **`$HISTFILE`**：命令历史文件的位置，默认是 `~/.bash_history`。
12. **`$HISTSIZE`**：保存在内存中的命令历史条目数。
13. **`$HISTFILESIZE`**：保存在 `$HISTFILE` 文件中的命令历史条目数。
14. **`$BASH_SUBSHELL`**：指示当前执行环境嵌套的子 shell 级别。具体来说，这个变量显示了当前 shell 在多少层子 shell 中运行。每当你启动一个新的子 shell，该值就会增加1。在顶层（即不是子 shell 的初始 shell）中，这个变量的值为0。

## Shell数学运算与双小括号

### 运算符号

| 运算符                                                       | 解释                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `+`, `-`, `*`, `/`, `%`                                      | 算术运算：加、减、乘、除、取模（分别对应）。例如：`$((a + b))`执行加法。 |
| `**`                                                         | 幂运算 - 返回第一个数的第二个数次幂。仅在某些shell如bash支持，需使用`$((a**b))`。 |
| `++`, `--`                                                   | 自增/自减 - 可以前缀或后缀形式使用来增加或减少变量值。注意：这些不常用在标准算术表达式中。 |
| `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `\|=`, `^=` | 赋值及复合赋值运算符。例如：`a+=b`等价于`a=a+b`。            |
| `-eq`, `-ne`, `-lt`, `-le`, `-gt`, `-ge`                     | 整数比较运算符：等于、不等于、小于、小于等于、大于、大于等于。用于条件测试如`if [ $a -eq $b ]; then ... fi`。 |
| `==`, `!=`, `<`, `>`, `<=`, `>=`                             | 字符串和数值比较运算符，通常与`[[ ]]`结合使用。如`[[ "abc" == "abc" ]]`返回真。 |
| `&&`, `||`, `!`                                              | 逻辑运算符：逻辑与、逻辑或、逻辑非。用于组合条件判断。例如：`[[ $a -gt 0 && $b -lt 10 ]]`。真1，假0 |
| `&`, `\|`, `^`, `~`, `<<`, `>>`                              | 位运算符：按位与、按位或、按位异或、按位非、左移、右移。常用于低级编程或标志处理。 |
| `-d`, `-f`, `-r`, `-w`, `-x`, `-s`                           | 文件测试运算符：检查路径是否为目录、普通文件、可读、可写、可执行、大小是否大于0。例如：`if [ -d "$path" ]; then echo "Is directory"; fi`。 |
| `-z`, `-n`                                                   | 字符串长度测试：`-z`检查字符串是否为空，`-n`检查字符串是否非空。如：`if [ -z "$str" ]; then echo "String is empty"; fi`。 |
| `-e`, `-nt`, `-ot`                                           | 额外文件测试：`-e`检查文件是否存在，`-nt`新于另一个文件，`-ot`旧于另一个文件。 |

* 逻辑运算
  * **逻辑与 (`&&`)**：当两个条件都为真时，整个表达式才为真。
  * **逻辑或 (`||`)**：只要其中一个条件为真，则整个表达式为真。
  * **逻辑非 (`!`)**：反转条件判断的结果。如果原条件为假，则结果为真；反之亦然。

### 运算命令

| 命令/结构       | 解释                                                         | 示例                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `$((...))`      | 算术扩展 - 用于执行整数运算。                                | `result=$((5 + 3))` 结果为8。                                |
| `expr`          | 执行简单算术或字符串操作的老式命令。                         | `expr 5 + 3` 输出8。注意：需要空格围绕运算符。               |
| `let`           | 对变量进行算术运算并赋值。                                   | `let a=5+3` 将8赋值给变量a。                                 |
| `[ ]` 或 `test` | 条件表达式 - 用于测试文件属性、字符串比较等。                | `[ 5 -gt 3 ] && echo "5 is greater than 3"` 输出"5 is greater than 3"。 |
| `[[ ]]`         | 改进版条件表达式 - 提供更强大的字符串处理功能（如模式匹配）及安全性。 | `[[ "hello" == "hello" ]] && echo "match"` 输出"match"。     |
| `(( ))`或`$[]`  | 整数算术条件表达式 - 类似于`$(( ))`，但用于条件判断。        | `(( 5 > 3 )) && echo "5 is greater than 3"` 输出"5 is greater than 3"。 |
| `bc`            | 计算器命令 - 用于高精度计算，支持浮点数运算。                | `echo "2 / 3" \| bc -l` 输出0.66666666666666666666。         |
| `printf`        | 格式化输出命令 - 可以用来格式化数字、字符串等。              | `printf "%.2f\n" $(echo "scale=2; 10 / 3" \| bc)` 输出3.33。 |
| `return`        | 从函数返回一个状态值（默认是最后一个命令的退出状态）。       | `function example { return 0; }` 返回成功状态。              |
| `exit`          | 终止当前脚本，并返回一个退出状态码。                         | `if [ "$?" -ne 0 ]; then exit 1; fi` 检查上一命令是否失败，若失败则退出脚本。 |

* 双小括号(())的操作方法
  * `((i=i+1))`：此种书写方法为运算后赋值法，即将 i+ 1 的运算结果赋值给变量 i。 注意，不能用 `echo ((i—i+l))` 的形式输出表达式的值，但可以用 `echo S((i=i+ l))` 输出其值
  * `i=$((i+1))`：可以在`(())`前加`$`符，表示将表达式运算后赋值给 i
  * `((8>7&&5==5))`：可以进行比较操作，还可以加人逻辑与和逻辑或用于条件判断
  * `echo $((2+!))`：需要直接输出运算表达式的运算结果时，可以在`(())`前加`$`符

### 特殊符号运算

* `++`：加一

* `--`：减一

  ==变量在符号前面，先计算变量在加一或者减一；变量在符号后面，先计算加一或者减一在计算变量==

### Let命令计算

==`let` 命令用于执行算术运算。它允许你对变量进行数值计算，并将结果赋值给变量==

* 基本语法

  ```shell
  let expression
  ```

  * `expression` 是一个包含算术运算的表达式。
  * `let` 会计算表达式的值，并将其结果存储到变量中。

### Expr命令

* 基本语法

  ```shell
  expr expression
  ```

  * `expression` 是要计算的表达式。
  * `expr` 会将表达式的计算结果输出到标准输出。

* **注意事项**

  1. **空格敏感**
     - 在使用 `expr` 时，操作符（如 `+`, `-`, `*`, `/` 等）前后必须有空格。
     - 例如：`expr 5 + 3` 是正确的，而 `expr 5+3` 是错误的。
  2. **特殊字符转义**
     - 某些符号（如 `*`）需要使用反斜杠 `\` 进行转义。例如：`expr 5 \* 3`。
  3. **返回值**
     - 如果表达式合法且计算成功，`expr` 返回 0；否则返回非 0。
  4. **整数运算**
     - `expr` 只支持整数运算，不支持浮点数。

| 功能         | 示例                            |
| ------------ | ------------------------------- |
| 加法         | `expr 5 + 3`                    |
| 减法         | `expr 10 - 4`                   |
| 乘法         | `expr 5 \* 3`                   |
| 除法         | `expr 10 / 2`                   |
| 取模         | `expr 10 % 3`                   |
| 字符串长度   | `expr length "hello"`           |
| 子字符串位置 | `expr index "hello world" "w"`  |
| 提取子字符串 | `expr substr "hello world" 1 5` |
| 比较         | `expr 5 = 5`                    |

## 函数

==函数的作用，就是把你写的功能代码，进行打包，封装成一个函数名，然后调用该函数名，函数就会执行==

```shell
# 函数名
print_aa（）{
# 函数体
echo "asda"
# 给脚本的执行结果，赋予一个状态码，退出码
exit 1
}
# 接收用户输入的命令，-p 参数后面写，用户到的示信息
# read语法：read -p "提示信息" 接收用户输入的变量
read -p "aslkdaskdh" firstnum
#执行函数
print_aa
```

### IF语句

* 基本语法

  ```shell
  if [ condition ]; then
      # 当条件为真时执行的代码
  elif [ another_condition ]; then
      # 当另一个条件为真时执行的代码
  else
      # 当所有条件都为假时执行的代码
  fi
  ```

  1. **`[ condition ]`**
     - `[ ]` 是测试命令（等价于 `test` 命令）。
     - 条件可以是文件检查、字符串比较、数字比较等。
     - 注意：`[` 和 `]` 前后需要有空格。
  2. **`then`**
     - `then` 表示条件成立时要执行的代码块。
     - 可以写在同一行，也可以换行。
  3. **`elif` 和 `else`**
     - `elif` 是可选的，用于处理多个分支。
     - `else` 是默认分支，当所有条件都不满足时执行。
  4. **`fi`**
     - `fi` 表示 `if` 语句的结束。

### 循环

==在 Shell 脚本中，循环语句用于重复执行一段代码。Shell 提供了多种循环结构，包括 `for`、`while` 和 `until`。以下是它们的详细语法和用法。==

1. `for` 循环

   基本语法

   ```shell
   for variable in list; do
       # 循环体
   done
   ```

   * `variable` 是循环变量。
   * `list` 是一个值列表（可以是数字、字符串或文件名等）。
   * 每次循环时，变量 `variable` 会依次取 `list` 中的值。

2. `while` 循环

   基本语法

   ```shell
   while [ condition ]; do
       # 循环体
   done
   ```

   * 只要 `condition` 条件为真，循环就会继续执行。

3. `until` 循环

   基本语法

   ```shell
   until [ condition ]; do
       # 循环体
   done
   ```

   * 与 `while` 相反，`until` 循环会在条件为假时继续执行，直到条件为真时停止。

4. 循环控制语句
   * `break`用于立即退出当前循环。
   * `continue`用于跳过当前迭代，直接进入下一次循环。
   * `exit`用于直接退出整个脚本。

## Shell条件测试开篇



## Shell测试语法参数解释

## Test命令与-E测试用法
## Test命令讲解二
## 条件测试与中括号详解
## 如何阅读优秀的脚本
## 字符串值判断逻辑

## 数值比较符号
## 逻辑运算符号
## 逻辑运算脚本一
## 趣谈逻辑脚本开发
## 趣谈if语法
## 开发内存检测脚本
## If实战一
## 如何检测服务状态
## 提升：学习php和python连接mysql
## Shell脚本检测mysql服务状态
## 轻松学习rsync专业脚本开发
## 理解为什么用函数

## 使用函数的关键点
## 如何使用函数一
## 提升：详解shell环境与函数执行
## 提升：图解函数脚本处理传入参数
## 函数脚本开发：检测网站存活
## 趣谈rsync起停脚本开发

