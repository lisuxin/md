[toc]

# 磁盘管理，进程管理

## 命令

### fidsk命令

1. 查看磁盘分区表
   * 使用 `fdisk -l` 查看系统中的所有磁盘及其分区信息。
   * 从 Linux 内核 2.17 开始，推荐使用 `lsblk` 或 `parted` 查看磁盘信息，因为它们输出更清晰。
2. 进入交互模式
   * `fdisk /dev/sdX`其中/dev/sdX 是目标磁盘设备名称
   * fdisk 交互模式常用命令
      * `m`	显示帮助菜单，列出所有可用命令。
      * `p`	打印当前磁盘的分区表。
      * `n`	创建新分区。
      * `d`	删除现有分区。
      * `t`	更改分区类型（例如设置为 Linux 文件系统或交换分区）。
      * `l`	列出所有可用的分区类型。
      * `w`	写入更改并退出。
      * `q`	不保存更改直接退出。
3. 创建新分区
   - 输入 `n` 创建新分区。
   - 选择分区类型（`p` 表示主分区，`e` 表示扩展分区）。
   - 指定分区号（如果自动分配则回车）。
   - 设置起始扇区（默认即可）。
   - 设置结束扇区或大小（例如 `+1G` 表示创建 1GB 的分区）。
4. 删除分区
   - 输入 `d` 删除分区。
   - 输入要删除的分区号。
5. 更改分区类型
   - 输入 `t` 更改分区类型。
   - 输入要修改的分区号。
   - 输入新的分区类型代码（例如 `83` 表示 Linux 文件系统，`82` 表示交换分区）。
6. 写入更改
   - 输入 `w` 将更改写入磁盘并退出。
   - 如果不想保存更改，可以输入 `q` 退出。
7. 注意事项
   1. 备份数据:在对磁盘进行分区操作前，请确保重要数据已备份，避免误操作导致数据丢失。
   2. 分区表类型
      * `msdos`：传统的 MBR 分区表，最多支持 4 个主分区。
      * `gpt`：GUID 分区表，支持更多分区和更大的磁盘容量。
      * 可以通过 `g` 命令将分区表类型转换为 GPT。
   3. 刷新分区表：如果分区表被修改但未生效，可以使用以下命令刷新内核分区表：`partprobe /dev/sdX`

### df命令

* 使用 df 命令可以查看硬盘的使用情况

   * 语法： `df [-h]`
   * 选顶： -h, 以更加人性化的单位显示
      * `-H`	类似于 -h，但使用 1000 而不是 1024 作为单位换算基数。
      * `-T`	显示文件系统类型（例如 ext4、xfs、tmpfs 等）。
      * `-i`	显示 inode（索引节点）的使用情况，而不是磁盘空间。
      * `-t <type>`	仅显示指定类型的文件系统（例如 -t ext4）。
      * `-x <type>`	排除指定类型的文件系统（例如 -x tmpfs）。
      * `--output`	自定义输出列（例如 --output=source,size,used,avail,pcent）。
* 使用 iostat 查看 CPU 、磁盘的相关信息

   * 语法： `iostat [-x] [num1] [num2]`

   * 选项：-x，显示更多信息
   * num1: 数字，刷新间隔， num2: 数字，刷新几次

### du命令

* `du`是 Linux 系统中用于查看文件或目录磁盘使用情况的命令。它可以统计文件和目录占用的磁盘空间，并以多种方式显示结果。
* 基本语法：`du [选项] [文件或目录]`
* 常用选项：
  * `-h`：以人类可读的方式显示（如 KB、MB、GB）。
  * `-s`：仅显示总计大小，而不列出每个子目录的大小。
  * `-a`：显示所有文件和目录的大小，而不仅仅是目录。
  * `-c`：在最后加上总计大小。
  * `-l`：计算硬链接文件的大小多次（默认只计算一次）。
  * `--max-depth=N`：限制递归深度为 N 级子目录。
  * `-x`：仅计算同一个文件系统中的文件，忽略挂载点以外的文件。
  * `--exclude=PATTERN`：排除匹配指定模式的文件或目录。

### partprobe 命令

* `partprobe` 是 Linux 系统中的一个命令，用于通知内核重新读取分区表信息。当磁盘分区表被修改，未自动更新到内核时，可以使用 `partprobe` 来刷新分区表，而无需重启系统。
* 基本语法`partprobe [选项] [设备]`
* 常用选项
   * `-d`	不尝试重新读取分区表，仅输出设备信息。
   * `-s`	显示设备及其分区的详细信息。
   * `-h`	显示帮助信息。
   * `-v`	显示详细的操作过程信息。

### partx 命令

* `partx` 是 Linux 系统中用于管理分区设备节点的命令，主要用于添加、删除或列出分区表中的分区设备节点。它通常在需要动态加载或卸载分区时使用，尤其是在通过工具（如 `fdisk` 或 `sgdisk`）修改磁盘分区后，`partx` 可以帮助内核识别新的分区。
* 基本语法：`partx [选项] [设备]`
* 常用选项
   * `-a`	添加所有分区到内核中（即创建对应的设备节点）。
   * `-d`	删除指定的分区设备节点。
   * `-r`	列出分区信息，并以可读格式输出。
   * `-g`	列出分区信息，并以脚本友好的格式输出（适合解析）。
   * `-l`	列出分区号及其范围。
   * `-n`	指定要操作的分区号（例如 -n 1 表示操作第一个分区）。
   * `--show`	显示分区信息而不进行任何更改。
   * `-v`	显示详细的操作过程信息。

### mkfs命令

* `mkfs` 命令是 Linux 系统中用于创建文件系统的工具。通过 `mkfs`，可以将一块裸磁盘格式化为特定的文件系统类型，以便操作系统能够使用它来存储和管理数据。
* 基本语法：`mkfs [选项] [-t 类型] 设备名`'
  * **设备名**：要格式化的磁盘分区或块设备（例如 `/dev/sdb1`）。
  * **类型**：指定要创建的文件系统类型（如 ext4、xfs、vfat 等）。
* 常用选项
  * `-t <类型>` 或 `--type=<类型>`：指定文件系统类型。
  * `-L <标签>`：为文件系统设置卷标（Label）。
  * `-v`：显示详细信息。
  * `-q`：静默模式，不输出任何信息。
  * `-F`：强制格式化，即使目标设备看起来不是一块未使用的磁盘。
* 常见文件系统类型
  * `ext2`：第二代扩展文件系统。
  * `ext3`：第三代扩展文件系统（支持日志功能）。
  * `ext4`：第四代扩展文件系统（性能更高）。
  * `xfs`：高性能日志文件系统。
  * `vfat`：适用于 Windows 兼容的 FAT32 文件系统。
  * `ntfs`：Windows NT 文件系统。
  * `btrfs`：先进的文件系统，支持快照和压缩。

### fsck命令

* `fsck`（File System Consistency Check）是 Linux 系统中用于检查和修复文件系统错误的工具。它可以检测文件系统的完整性，并尝试修复损坏的文件系统。
* 基本语法：`fsck [选项] 设备名`
  * **设备名**：目标文件系统所在的设备（例如 `/dev/sda1`）。
* 常用选项
  * `-a`：自动修复文件系统错误，无需用户干预。
  * `-n`：以只读模式运行，不进行任何修改，仅显示可能的操作。
  * `-r`：在需要时提示用户是否进行修复操作。
  * `-y`：对所有提示回答“是”（yes），通常与自动化脚本配合使用。
  * `-t <类型>`：指定文件系统类型（如 ext4、xfs 等）。
  * `-f`：强制检查文件系统，即使文件系统标记为“干净”。
  * `-v`：显示详细信息。

### dumpe2fs命令

* `dumpe2fs` 是一个用于显示 ext2、ext3 和 ext4 文件系统超级块和块组信息的工具。它可以帮助用户查看文件系统的详细结构和元数据，例如文件系统状态、挂载次数、日志信息等。
* 基本语法：`dumpe2fs [选项] 设备名`
  * **设备名**：目标文件系统所在的设备（例如 `/dev/sda1`）。
* 常用选项
  * `-h`：仅显示超级块信息，而不显示完整的块组信息。
  * `-b`：以二进制格式显示块大小。
  * `-f`：显示所有信息，包括详细的间接块映射。
  * `-x`：以十六进制转储文件系统内容。
  * `-V`：显示版本信息。

### xfs_info命令

* `xfs_info` 是一个专门用于显示 XFS 文件系统信息的命令。它能够提供关于 XFS 文件系统的详细元数据，包括块大小、inode 大小、日志位置、分配策略等。
* 基本语法：`xfs_info 设备名`

### tune2fs命令

* `tune2fs` 是一个用于调整 ext2、ext3 和 ext4 文件系统参数的工具。通过 `tune2fs`，可以修改文件系统的各种属性，例如卷标、最大挂载次数、检查间隔等。

* 基本语法：`tune2fs [选项] 设备名`

* 常用选项

  * 修改卷标（Volume Label）：`-L <标签>`：设置文件系统的卷标。`tune2fs -L mydisk /dev/sda1`

  * 修改最大挂载次数：`-c <次数>`：设置文件系统在强制检查之前允许的最大挂载次数。`tune2fs -c 50 /dev/sda1`这表示文件系统在被挂载 50 次后会触发`fsck` 检查。

  * 修改检查时间间隔：`-i <时间>`：设置文件系统在两次检查之间的时间间隔（单位为天）。`tune2fs -i 30 /dev/sda1`这表示文件系统每隔 30 天会触发一次检查。

  * 修改预留块比例：`-m <百分比>`：设置保留给超级用户的块比例（默认为 5%）。`tune2fs -m 1 /dev/sda1`这将把保留块的比例从默认的 5% 减少到 1%。

  * 启用/禁用日志功能：`-j`：为 ext2 文件系统启用日志功能，将其转换为 ext3 文件系统。`tune2fs -j /dev/sda1`

  * 查看文件系统信息：`-l`：列出文件系统的详细信息。`tune2fs -l /dev/sda1`

    * 输出示例：

      ```shell
      Filesystem volume name:   mydisk
      Last mounted on:          /
      Filesystem UUID:          123e4567-abcd-8910-efgh-1234567890ab
      Filesystem magic number:  0xEF53
      Filesystem state:         clean
      Blocks count:             1048576
      Free blocks:              524288
      Inodes count:             262144
      Free inodes:              200000
      First block:              0
      Block size:               4096
      Fragment size:            4096
      Reserved GDT blocks:      1024
      ```

  * 修改文件系统 UUID：`-U <UUID>`：设置文件系统的 UUID。`tune2fs -U random /dev/sda1`使用`random` 参数可以生成一个新的随机 UUID。

  * 禁用自动检查：

    * `-C <计数>`：设置当前挂载计数。`tune2fs -C 0 /dev/sda1`将挂载计数重置为 0，避免触发自动检查。

    - `-I <秒数>`：设置上次检查时间。`tune2fs -T now /dev/sda1`将上次检查时间设置为当前时间。

### lsblk命令

* `lsblk` 是 Linux 系统中用于列出块设备信息的命令。它可以显示所有块设备（如硬盘、分区、光驱等）的层次结构，包括设备名称、大小、挂载点等信息。
* 基本语法：`lsblk [选项]`
* 常用选项：
  * 显示详细信息
    * `-a`：显示所有块设备，包括没有挂载的设备。
    * `-f`：显示文件系统类型和挂载点。
    * `-b`：以字节为单位显示设备大小。
    * `-o`：指定输出列，例如 `NAME,SIZE,MOUNTPOINT,FSTYPE`。
  * 格式化输出
    * `--nodeps`：仅显示顶级设备，不显示子设备（如分区）。
    * `--tree`：以树状结构显示设备层次关系（默认格式）。
    * `--noheadings`：不显示表头。
    * `--pairs`：以键值对的形式输出。

### mount命令

* `mount` 是 Linux 系统中用于挂载文件系统的命令。通过 `mount`，可以将磁盘分区、网络文件系统或其他存储设备挂载到指定的目录（挂载点），从而使其可以被访问。

* 基本语法：`mount [选项] [-t 类型] 设备名 挂载点`

  * **设备名**：要挂载的设备或远程文件系统（例如 `/dev/sda1` 或 `server:/path`）。
  * **挂载点**：目标目录，设备将挂载到该目录下。

* 常用选项

  * `-l`：显示系统所有挂载信息

  * 指定文件系统类型：`-t <类型>`：指定文件系统类型（如 `ext4`、`xfs`、`vfat`、`nfs` 等）。

    ```shell
    mount -t ext4 /dev/sda1 /mnt
    ```

  * 只读挂载：`-r`：以只读方式挂载文件系统。

    ```shell
    mount -r /dev/sda1 /mnt
    ```

  * 设置挂载选项：`-o <选项>`：指定挂载选项。多个选项可以用逗号分隔。 常见选项包括：

    - `ro`：只读挂载。

    - `rw`：读写挂载（默认）。

    - `noexec`：禁止执行文件。

    - `nosuid`：忽略 SUID 和 SGID 位。

    - `sync`：同步写入数据（默认为异步）。

    - `defaults`：使用默认选项（等同于 `rw, suid, dev, exec, auto, nouser, async`）。

      ```shell
      mount -o ro,noexec /dev/sda1 /mnt
      ```

  * 显示已挂载的文件系统：不带参数直接运行 `mount`，可以显示当前系统中所有已挂载的文件系统。

    ```shell
    mount

  * 挂载 NFS 文件系统：对于网络文件系统（NFS），可以使用以下命令：

    ```shell
    mount -t nfs server:/remote/path /local/mountpoint
    ```

  * 自动挂载：`-a`：根据`/etc/fstab`文件中的配置，挂载所有未挂载的文件系统。

    ```shell
    mount -a
    ```

### stat命令

* `stat` 是 Linux 系统中用于显示文件或文件系统状态的命令。它提供了比 `ls -l` 更详细的文件属性信息，包括文件的 inode、设备号、访问时间、修改时间等。

* 基本语法：`stat [选项] 文件名`

* 常用选项

  * 显示文件状态：默认情况下，`stat` 会显示文件的详细信息。

    ```shell
    stat 文件名

  * 格式化输出：`-c <格式>`：自定义输出格式。 常用格式说明符：

    - `%n`：文件名。

    - `%s`：文件大小（字节）。

    - `%a`：文件权限（八进制）。

    - `%u` 和 `%g`：文件的所有者和组 ID。

    - `%x`、`%y`、`%z`：分别表示访问时间、修改时间和更改时间。

      ```shell
      stat -c "%n %s bytes" 文件名

  * 显示文件系统状态`-f` 或 `--file-system`：显示文件所在文件系统的状态，而不是文件本身的属性。

    ```shell
    stat -f 文件名
    ```

  * 显示简要信息：`-t`：以简洁格式显示文件的状态。

    ```shell
    stat -t 文件名
    ```


### mkswap命令

* `mkswap` 是 Linux 系统中用于设置交换空间（swap space）的命令。它可以将一个文件或分区标记为交换空间，并使其能够被内核用作虚拟内存。
  * 基本语法：`mkswap [选项] 设备或文件`
  * 常用选项：
    * `-c`：在设置交换空间之前检查坏块。
    * `-f`：强制设置交换空间，即使设备或文件看起来太大或太小。
    * `-v{0|1}`：设置 verbose 模式，`-v0` 表示不输出任何信息，`-v1` 表示输出基本信息。
    * `-L 标签`：为交换空间指定一个标签。
    * `-p 交换区偏移量`：指定交换区的偏移量（通常不需要使用）。
    * `-U UUID`：为交换空间指定一个 UUID。

### free命令

* `free` 是 Linux 系统中用于显示系统内存使用情况的命令，它可以报告物理内存（RAM）和交换空间（swap）的总量、已用和空闲量。
* 基本语法：`free [选项]`
* 常用选项：
  * `-b`：以字节（bytes）为单位显示内存信息。
  * `-k`：以千字节（KB）为单位显示内存信息（默认）。
  * `-m`：以兆字节（MB）为单位显示内存信息。
  * `-g`：以吉字节（GB）为单位显示内存信息。
  * `-h`：以人类可读的方式显示内存信息（自动选择合适的单位，如 KB、MB 或 GB）。
  * `-t`：显示总和行（包括总计的内存和交换空间）。
  * `-s <秒>`：每隔指定的秒数刷新一次输出（类似于 `watch` 命令）。
  * `-l`：显示详细的内存信息（区分缓存类型）。
  * `-o`：不显示缓冲区调整后的数据。
  * `--help`：显示帮助信息。
  * `--version`：显示版本信息。

### mdadm命令

* `mdadm` 是 Linux 系统中用于管理软件 RAID（冗余磁盘阵列）的工具。它可以创建、监控和管理 RAID 设备，支持多种 RAID 级别（如 RAID 0、RAID 1、RAID 5 等）。
* 基本语法：`mdadm [模式] [选项] [RAID设备] [成员设备]`
* 常用选项：
  * `-C` 或 `--create`：创建一个新的 RAID 阵列。
  * `-A` 或 `--assemble`：组装已有的 RAID 阵列。
  * `-D` 或 `--detail`：显示 RAID 阵列的详细信息。
  * `-E` 或 `--examine`：检查超级块信息。
  * `-F` 或 `--follow`：监控 RAID 阵列状态。
  * `-S` 或 `--stop`：停止一个正在运行的 RAID 阵列。
  * `-v` 或 `--verbose`：输出详细信息。
  * `-l` 或 `--level`：指定 RAID 级别（如 0、1、5 等）。
  * `-n` 或 `--raid-devices`：指定参与 RAID 的设备数量。
  * `-a` 或 `--auto`：自动检测和组装 RAID 阵列。
  * `-f` 或 `--fail`：标记某个设备为故障状态。
  * `-r` 或 `--remove`：从 RAID 中移除某个设备。
  * `-a` 或 `--add`：向 RAID 中添加新设备。

### pv物理卷

* 在Linux系统中，`pvcreate`、`pvscan`、`pvdisplay` 和 `pvremove` 是与 LVM（逻辑卷管理，Logical Volume Manager）相关的命令。这些命令用于管理物理卷（Physical Volume），它是LVM的基础组件。

#### pvcreate初始化物理卷

*  将一个或多个块设备（如硬盘分区）初始化为物理卷，以便它们可以被LVM使用。
* 基本语法：`pvcreate [选项] 设备名`
* 常用选项:
  * `-f`: 强制执行操作，无需确认。
  * `-y`: 自动回答“yes”以避免交互式提示。
  * `-v`: 显示详细信息。

#### pvscan扫描并列出所有物理卷

* 扫描系统中的所有物理卷，并显示相关信息。
* 基本语法：`pvscan [选项]`
* 常用选项：
  * `-v`: 显示详细信息。
  * `-a`: 显示所有物理卷，包括未分配的卷。

#### pvdisplay显示物理卷的详细信息

* 显示物理卷的详细信息，例如大小、UUID、状态等。
* 基本语法：`pvdisplay [选项] [设备名]`
* 常用选项:
  * `-c`: 以紧凑格式显示输出。
  * `-m`: 显示映射信息。

#### pvremove移除物理卷的LVM元数据

* 从物理卷中移除LVM元数据，使该设备不再作为物理卷使用。
* 基本语法：`pvremove [选项] 设备名`
* 常用选项:
  * `-f`: 强制执行操作，无需确认。
  * `-y`: 自动回答“yes”以避免交互式提示。

### vg卷组

在Linux系统中，`vgcreate`、`vgscan`、`vgdisplay`、`vgreduce`、`vgextend` 和 `vgremove` 是与 LVM（逻辑卷管理，Logical Volume Manager）相关的命令。这些命令用于管理卷组（Volume Group），它是LVM的核心组件之一。

以下是这些命令的详细介绍：

---

#### vgcreate创建卷组

*  创建一个新的卷组（Volume Group），并将一个或多个物理卷（Physical Volume）添加到该卷组中。

* 基本语法：`vgcreate [选项] 卷组名 物理卷设备...` 

* 常用选项：
  * `-s <大小>`: 设置逻辑区内块（PE，Physical Extent）的大小。
  * `-l <数量>`: 设置逻辑区内块的最大数量。
  * `-p <数量>`: 设置物理卷的最大数量。

#### vgscan扫描并列出所有卷组

* 扫描系统中的所有卷组，并检测可用的卷组。

* 基本语法：`vgscan [选项]` 

* 常用选项：
  * `-v`: 显示详细信息。
  * `-a y`: 激活找到的所有卷组。

#### vgdisplay显示卷组的详细信息

* 显示卷组的详细信息，例如大小、状态、物理卷和逻辑卷的数量等。

* 基本语法：`vgdisplay [选项] [卷组名]`

* 常用选项：
  * `-c`: 以紧凑格式显示输出。
  * `-v`: 显示更详细的输出。

#### vgreduce从卷组中移除物理卷

* 从卷组中移除一个或多个物理卷。

* 基本语法：`vgreduce [选项] 卷组名 物理卷设备...` 

* 常用选项：
  * `-f`: 强制执行操作。
  * `--removemissing`: 移除丢失的物理卷。

#### vgextend向卷组中添加物理卷

* 将新的物理卷添加到现有的卷组中。

* 基本语法：`vgextend [选项] 卷组名 物理卷设备...` 

#### vgremove删除卷组

* 删除一个卷组及其所有相关联的逻辑卷和物理卷的元数据。

* 基本语法：`vgremove [选项] 卷组名` 

* 常用选项：
  * `-f`: 强制执行操作。

### lv逻辑卷

在Linux系统中，`lvcreate`、`lvscan`、`lvs`、`lvdisplay`、`lvextend`、`lvreduce` 和 `lvremove` 是与 LVM（逻辑卷管理，Logical Volume Manager）相关的命令。这些命令用于管理逻辑卷（Logical Volume），它是LVM的最终存储单元。

#### lvcreate创建逻辑卷

* 创建一个新的逻辑卷（Logical Volume）。

* 基本语法：`lvcreate [选项] 卷组名` 

* 常用选项：
  * `-L <大小>`: 指定逻辑卷的大小（例如 `10G` 表示 10GB）。
  * `-l <数量>`: 指定逻辑卷使用的物理区内块（PE）数量。
  * `-n <名称>`: 指定逻辑卷的名称。
  * `-W y`: 忽略警告信息。

#### lvscan扫描并列出所有逻辑卷

* 扫描系统中的所有逻辑卷，并列出它们。

* 基本语法：`lvscan [选项]` 

* 常用选项：
  * `-a`: 显示所有活动的逻辑卷。
  * `-v`: 显示详细信息。

#### lvs简洁显示逻辑卷的概要信息

* 以简洁的方式显示逻辑卷的概要信息。

* 基本语法：`lvs [选项]` 

* 常用选项：
  * `-o`: 指定输出的列（如 `lv_name,vg_name,size`）。
  * `-a`: 显示所有逻辑卷，包括隐藏的逻辑卷。

#### lvdisplay显示逻辑卷的详细信息

* 显示逻辑卷的详细信息，例如路径、大小、状态等。

* 基本语法：`lvdisplay [选项] [逻辑卷路径]` 

* 常用选项：
  * `-c`: 以紧凑格式显示输出。
  * `-v`: 显示更详细的输出。

#### lvextend扩展逻辑卷的大小

* 扩展逻辑卷的大小。

* 基本语法：`lvextend [选项] 逻辑卷路径` 

* 常用选项：
  * `-L +<大小>`: 增加逻辑卷的大小（例如 `+5G` 表示增加 5GB）。
  * `-l +<数量>`: 增加逻辑卷使用的物理区内块（PE）数量。

#### lvreduce缩小逻辑卷的大小

* 缩小逻辑卷的大小。

* 基本语法：`lvreduce [选项] 逻辑卷路径` 

* 常用选项：
  * `-L <大小>`: 设置逻辑卷的新大小。
  * `-r`: 自动调整文件系统大小。

#### lvremove删除逻辑卷

* 删除逻辑卷及其元数据。

* 基本语法：`lvremove [选项] 逻辑卷路径` 

* 常用选项：
  * `-f`: 强制执行操作。

## 磁盘管理

==磁盘使用过程：磁盘分区——>磁盘格式化、创建文件系统——>挂载目录——>读写数据==

1. 磁盘管理的名词解释
   * 扇区 sector 是磁盘中最小的物理存储单元，单位 512 字节 512 bytes
   * 操作系统无法对数目众多的扇区进行寻址，因此操作系统将相邻的扇区组合在了一起，形成了块 block 。
   * 在 Linux 文件系统中多个连续的扇区，被称之为 btock ，块的概念，也是在系统中被认为是最小的存储单位操作系统规定，一个 block 只能存放一个文件的内容，因此文件占用的空间大小，只能是 block 的整数倍即使文件大小，小于一个块，也就是小于 4k ，同样的占用一个 block 大小
   * 分区编辑器，`partiion` 、`editor`
   * `fdisk` 对磁盘进行格式化的命令，以及分区等
2. 分区表 `mbr`、`gpt`
   * mbr 分区表
      * master boot record ，主分区引导记录
      * mbr 分区关注的是，硬盘容量受限制，最大 2T
   * gpt 分区表
      * 现在大多的硬盘分区表，都是 gpt 分区表了
      * 优点
      * gpt 分区表硬盘容量没有限制
      * 分区个数没有限制
      * 自带磁盘保
3. 常见的文件系统
   * fat16 fat32，最早的 windos 的文件系统，缺点是单个文件，不能超过 2GB
   * NTFS 文件系统，支持文件加，采用日志形式的文件系统，详细的记录磁盘读写的操作，支持数据恢复，能够提高磁数据的安全性，突破了单个文件 4G 大小的限制
   * exFAT文件系统，新式的文件系统，单个文件支持 16GB 大小，能够在 windows 和 Linux, macos 中同时识别
4. 磁盘的 RPM ，硬盘内电机主轴的旋转速度，也就是硬盘盘片在一分钟内能够完成的最大旋转数。
5. 磁盘性能检测
   * `input/output`、`operations`、`per`、`second` 这个值越大，代表磁盘性能越高
6. ide 硬盘，会被 Linux 识别为`/dev/hda /dev/hdb /dev/hdc /dev/hdd`
7. 一个硬盘的结构如下：
   * 系统默认分区1~4留给了主分区和扩展分区
   * 主分区 1 `*`（星号代表是引导分区，引导分区装在这里）
   * 主分区 2
   * 主分区 3
      * 逻辑分区 n

### 磁盘分区

1. 查找全部磁盘

   ```shell
   fdisk -l |grep sd
   ```

2. 进入交互磁盘

   ```shell
   fdisk /dev/sdb
   # 添加分区
   n
   # 设置主分区或扩展分区(二选一)
   p # 主分区
   e # 扩展分区
   # 输入区号，默认1
   1
   # 设置起始扇区，默认2048
   2048
   # 设置扇区大小
   +256m
   ```

3. 在没有进入`n`添加分区`p`为打印当前分区表

4. 将分区写入磁盘并退出`w`

5. 查看磁盘分区表号`cat /proc/partitions`

6. `partprobe` 命令centos5 或者以前使用此命令，可以用于重读分区表，当删除文件后，仍然占用磁盘空间，是因为磁盘分区表没更新，需要重启分区表，可以使用此命令，不重启电脑，重读分区表`partprobe /dev/sdb`：重读磁盘`/dev/sdb` 的分区表信息

7. `partx` 命令partx 命令用于告诉 linux 内核，新的磁盘分区情况，让内核重读分区表

8. 删除磁盘

   ```shell
   # 进入
   fdisk /dev/sdb
   # 删除
   d
   #输入分区号，默认最后一个
   ```

   

### 针对超过2TB的磁盘分区

1. 小于 2TB 的磁盘都可以用 fdisk 分区，但是大于 2T8 的磁盘，只能用 parted 命令分区，且转换磁盘为 GPT 格式

2. `parted`（只有主分区和扩展分区没有逻辑分区）

   ```shell
   # 进入
   pardet /dev/sdc
   # 查看命令
   help
   # 修改磁盘类型
   mklobel gpt
   # 打印分区表类型
   p
   # 创建主分区
   mkpart primary 0 500 #mkpart 主分区 起始位置 大小
   # 创建扩展分区
   mkpart logical 501 10000
   # 退出
   q
   ```

### 文件系统

1. 软硬连接
   * 软连接`ln -s 目标文件或文件夹的绝对路径 连接方式的绝对路径`
   * `readlink`查看软连接；`realink 软件连接路径`
   * 文件系统
     * 操作系统中专门用于管理和存储文件的信息软件被称之为文件系统
     * 文件是以文件数据+文件元信息组成的，文件的 inode 号+文件数据内容，代表一个单个文件
     * 文件系统又将文件元信息（元信息，存放文件的创建信息，修改信息，文件大小，等等）存储在了一个称之为 inode 区域的地方，中文叫做 索引节点
     * 查看文件inode号：`ls -li 文件`
     * 通过 `ls -l` 查看到的数据，唯独文件名不属于 inode 存储的元信息
     * inode 元数据区，保存的是
       * 文件大小
       * 属主信息
       * 用户组信息
       * 文件权限数字
       * 文件的修改时间
       * 还存储了一个文件的实体指针，指向 block 的位置
   * inode 大小的关系
     * 硬盘在格式化的时候，系统自动的分为了 2 部分，一个部分是元数据区域，存放文件的 inode 信息，一个是文件数据内容区域
     * 每个 inode 的大小，都是在格式化分区的时候，决定好了，默认是 128 字节或是 256 字节
     * 查看本机inode大小`dumpe2fs -h /dev/vda1|grep -i 'inode size'`
   * block 磁盘块
     * 磁盘盘片上的多个连续的扇区，文件系统以 block 进行读写数据
   * 硬链接
     * 一般情况下，文件名和 inode 号是一对一的
     * 创建硬链接`ln 目标文件绝对路径 硬链接文件路径`
   * 软硬链接特点
     * 硬链接
       * 目录文件夹，不支持硬琏接
       * 不得跨文件系统
       * 硬链接数据量的增加，会增加 inode 号码的计数
     * 软连接
       * inode 号码，是不一样的，代表软连接文件，是两个单个的个体，硬鲢接的 inode 号是一样的
       * 软连接可以针对文件夹操作
   * 软硬链接比较
     1. 删除软连接对源文件和硬链接无影响
     2. 删除硬链接，对软连接，源文件，也是无影响
     3. 删源文件，对硬链接也是无影响的，但是影响软连接，
     4. 只有删除源文件，和所有的硬接，文件的连接数就为 0 了，此时文件数据丢失
     5. 源文件和硬链接具有相同的 inode 号码，可以理解为，一个超币有多个入口，都是指向同一个超市
     6. 软连接和文件的 inode 号码不同，因此是 2 个单独的文件
2. 文件系统格式化
   * `mkfs`：针对磁盘分区进行格式化文件系统
   * `fsck`：命令，修复文件系统的命令
     * 默认读取 `/etc/fstab` 开机挂载文件的
   *  查看文件系统的属性
     * 对于Centos7 之前的文件系统，使用 dumpe2fs 命令，打印文件系统的块组信息适用于 ext2 ext3 ext4
     * 对于Centos7 之后的系统而言默认用的是 xfs 文件系统，使用 xfs_info 打印文件系统信息
   * `tune2fs `命令设置 tinux 是否开机自动检查文件系统正常与否
   * `lsblk` 命令列出所有的设备以及文件系统信息`lsblk -f`
   * 格式化
     * 格式化文件系统`mkfs.文件系统类型 磁盘`、`mkfs.xfs /dev/sdc1`
     * 关闭文件系统自检`tune2fs -c -1 /dev/sdc1`
     * 禁止文件系统开机自检：修改 `/etc/fstab 文件`然后改成如下设置：结尾的数字是 0 就不检查错误， 1 就检查错误
     * 针对磁盘进行修复检查：`fsck -t 文件系统类型 设备名`、`fsck -t xfs /dev/sdc1`
3. 文件系统挂载原理
   * Linux 下，设备不挂载的话，无法使用
   * 例如：`/dev/sdb2` 这些都是Linux 的磁盘设备文件，无法直接使用，读写数据
   * 挂载通常是将一个存储设备挂接到另一个已经存在的文件夹中，访问这个文件夹，就是访问该存储设备的内容了
   * 挂载完事之后， linux 上的普通文件夾，被称之为挂载点
   * 挂载`mount [选项] [-t 类型] 设备名 挂载点`
   * 取消挂载`umount 挂载点`：当前无人使用时才能取消挂载

### buff和cache解析

1. buffers：缓冲区、写入数据时，加速使用的

   * Buffers 表示在写入磁盘数据的时候，把分散的操作临时保存到内存中，达到一定的数量之后，集中写入到磁盘，减少磁盘碎片，加速数据查找，减少磁头的反复的寻道时间

2. cached：缓存、读取数据时，加速使用的

   * cached表示把数据从磁盘上读取出来，保存在内存中，再次读取的时候，不再去硬盘上拉去数据，直接从内存中读取，加速查找。

3. swap交换分区使用

   * 是Linux 系统磁盘管理的一块特殊的分区，当实际的物理内存不足的时候，操作系统会从整个内存中，取出一部分暂时没在使用的内存，拿出来放到交换分区，从而提供给当前正在使用的程序，可以使用更多的内存。

   * 使用 swap 分区作用是，通过操作系统的调取，程序可以用到的实际内存，会远大于物理内存

   * swap 分区大小．必须相据物理内存和硬盘容量来计算

     * 当你的物理内存小于 1G ，必须使用 swap 提升内存使用量
     * 内存使用过多的应用程序，比如图像，视频等，心须用 swap 分区防止物理内存不足，造成软件崩溃
     * 过当你的电脑休眠，内存中的数据会 swap 交换分区中，当你电脑恢复后，再从 swap 中读取数据，恢复软件正常工作

   * 创建swap分区

     * 分配规则

     * 内存小于 2G ， swap 分配和内存同样大小的空间

     * 内存大于 2G ， swap 也就分配 2G 的空间

       ```shell
       # 进入磁盘
       fdisk /dev/sdc
       # 查看分区
       p
       # 创建分区
       n
       # 创建主分区
       p
       # 输入分区号、创建起始点、设置分区大小
       # 指定分区类型
       t  # 选择分区
       82 #输入swap分区类型代码
       p  # 查看分区类型
       # 写入磁盘
       w
       
       # 磁盘格式化
       mkswap /dev/sdc1
       # 查看当前主机swap空间有多大
       free -m
       # 开启swap空间
       swapon /dev/sdc1
       # 关闭swap空间
       swapoff /dev/sdc1
       ```

4. 开机自动挂载与磁盘容量统计

   * 解决的问题：提升内存不足、但是在buff和cached中存在大量内存，如何释放

   * 解决方案：正在使用`buff和cached`不能使用

     * `echo 1 > /proc/sys/vm/drop_caches`或`sysctl -w vm.drop_caches=1`：删除缓存生效，释放cached
     * `echo 2 > /proc/sys/vm/drop_caches`：释放目录缓存和inodes
     * `echo 3 > /proc/sys/vm/drop_caches`：清楚内存页的缓存

   * 使用 `sync` 命令．可以用于清理僵尸进程

     * `sync` 的作用：将内存缓冲区的数据，写入到磁盘中

   * 由于 mount 命令直接输是临时生效，下次重启，挂载的设备分区就无法使用`/etc/fstab`文件，存放系统一些静态文件的地方，主要是系统启动的时候，系统会默认的读取这个文件的信息，将指定的挂载点，进行挂载。

   * 通过 `mount -a` 命令，可以读取`/etc/fstab` 文件所有的挂载情况

   * `fstab`文件内容

     ```shell
     # <file system> <mount point>   <type>  <options>       <dump>  <pass>
     /dev/sda1       /               ext4    defaults        0       1
     UUID=1234-5678  /boot           vfat    defaults        0       2
     LABEL=mydisk    /media/mydisk   ntfs    defaults,noauto 0       0
     //server/share  /mnt/share      cifs    username=user,password=pass 0 0
     # <file system>表示设备或文件系统的位置。
     # <mount point>挂载点，表示该文件系统将被挂载到哪个目录。
     # <type> 文件系统的类型。
     # <options>挂载选项，用于指定挂载时的行为。
     # <dump> 用于备份程序（如 dump）决定是否需要备份。值为 0 表示不备份，值为 1 表示需要备份。
     # <pass>用于 fsck 决定检查文件系统的顺序。值为 0 表示不检查。值为 1 表示在根文件系统上优先检查。值为 2 表示在其他文件系统上按顺序检查。
     ```

   * 检查挂载点使用情况`df -hT`

   * 显示磁盘空间大小，文件大小的命令`du -h`

### raid即磁盘冗余阵列

* ==raid 技术是将块独立的磁盘，组成了一个磁盘组，磁盘阵列==；RAID 是一种把多块独立的物理硬盘按不同方式组合起来形成一个逻辑硬盘，从而提供比单个硬盘有着更高的性能和提供数据冗余的技术。
* raid 技术分为多个级别，不同的级别，由于技术角度的考虑，运营成本的考虑，选择不同的版本的 raid 技术
  * raid 0：特点是数据依次写入到物理硬盘，在理想的状态下，写入速度是翻倍
    * 特点是，但凡任意坏了一块硬盘，数据都将被破坏。数据写入到 2 块硬盘中，没有备份的功能
    * 适用于追求极致性能的场景，而不关注于数据安全性的场景。
    * 读写效率更高，但是数据没有安全性保障
  * raid 1：将两块以上的硬盘绑定关系，数据写入的时候，同时写入多块硬盘，因此即使硬盘故障损坏也有备份，但是会使硬盘存储容量除以绑定的硬盘数量，减少利用率。
  * raid 3：必须需要 3 块以上的硬盘，将磁盘1和磁盘2 的异或值存储在磁盘3，无论是磁盘1还是磁盘2损坏，都可以通过磁盘3推导而出其余两个磁盘，但是存储异或值的磁盘3不能损坏；例磁盘1：0101，磁盘2：1011，异或结果磁盘3：1110，
    * 异或：数字相同则为 0 ，数字不同的则为 1
  * raid 5：相对于raid 3，raid 5会将三块磁盘都存储另外两块磁盘的异或结果。不能同时挂到两块。
  * raid 10：是raid 1加上raid 0，至少需要四块磁盘
* 软raid：Rraid 的学习（在 linux 系统上，通过软件命令，创建 raid 磁盘阵列）；由 cpu 去控制硬盘驱动器，进行数据转换，计算的过程就是软件 raid 的实现原理）
* 硬raid：硬 raid 直接购买 raid 阵列卡即可按照说明配置
  * 互联网公司一般都会购买 raid 卡（硬 raid)
  * 数据冗余性能从好到坏，raid 1ra id 10ra id 5ra id 0
  * 数据读写性能从好到怀，raid 0， raid10raid5， raid 1
  * 成本从高到底， raid 0 ，raid 10 ， ra id 1 ， raid 5
  * 不同场景，raid的选择
  * 单台服务器，数据很重要，但是磁盘不多，建议选择 raid1
  * 用作数据库服务器，存储服务器，（主从服务器建议用 raid 10），从服务器（ raid 5 ，减少成本）
  * WEB服务器（展示图片，视频等），没有太多数据的话，建议选择 raid 5 ， raid 0
  * 有多台服务器，监控服务器，应用服务器（登录注册与数据库打交道的后台服务器），建议用 raid 0 ， raid 5（提升磁盘读写效率）
* 硬 raid 和软 raid 的区别．
  * 软 raid 会额外的消耗 cpu 资源，造成服务器压力
  * 硬 raid 更加稳定，并且软件 raid 可能会造成磁盘发热过量，造成损坏
  * 硬 raid 兼容性更好，软 raid 兼容性依赖于操作系统，可能会出问题

### raid 10

1. 部署raid 10（准备4块磁盘）

   ```shell
   # 安装mdadm
   yum install mdadm -y
   # 创建 raid 10
   mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde
   # -C 表示创建raid阵列
   # v 显示创建过程
   # 表示reid磁盘阵列的名字
   # -a yes 自动创建磁盘阵列文件
   # -n 4 表示用4块磁盘创建阵列
   # -l 10 表示创建的raid的级别
   # 最后是四块硬盘的名字
   ```

2. 针对磁盘阵列设备，进行文件系统格式化，将`/dev/md0` 格式化为 xfs 文件系统`mkfs.xfs /dev/md0`

3. 对分区进行文件夹挂载，使用磁盘分区；创建文件夹用于挂载`mkdir /guazai`

4. 挂载`mount /dev/md0 /guazai/`

5. 检查挂载情况`mount -l | grep md0`

6. 检查 raid10 的详信息`mdadm -D /dev/md0`

7. 检查挂载空间的使用情况`df -hT|grep md0`

8. 取消挂载`umount /dev/md0`

9. 写入开机挂载文件中`/dev/md0  /guazai  defaults  0 0`

**故障修复**

1. 剔除一块设备`mdadm /dev/md0 -f /dev/sdd`
2. 检查raid10状态`mdadm -D /dev/md0`:即使挂掉了一块硬盘也不会影晌整个 raid10 的使用
3. 新的硬盘设备，从新加入 raid10 磁盘列组中即可
   * 取消挂载`umount /dev/md0`，重启
   * 重新加入新磁盘`mdadm /dev/md0 -a /dev/sdd`
   * 检查raid10状态`mdadm -D /dev/md0`
   * 等待修复完毕

**重启reid10**

1. 生成raid配置文件：`echo DEVICE /dev/sd[b-e] > /etc/mdadm.conf`
2. 扫描磁盘信息追加到磁盘中：`mdadm -Ds >> /etc/mdadm.conf`
3. 取消挂载`umount /dev/md0`
4. 停止raid10服务：`mdadm -S /dev/md0`
5. 检查raid10状态`mdadm -D /dev/md0`；看不到设备文件，即是正常状态了
6. 正常的在启动 raid10了：`mdadm -A /dev/md0`
7. 检查raid10状态`mdadm -D /dev/md0`

**卸载reid10**

1. 卸载挂载中的设备`umount /dev/md0`
2. 停止raid10服务：`mdadm -S /dev/md0`
3. 卸载 raid10 中所有的磁盘倌息`mdadm --misc --zero-superblock dev/sd(b到d)`
4. 删除 raid 的配置文件`rm /etc/mdadm.conf -y`
5. 清除开机挂载配置文件

**热备份**

1. 创建raid5：`mdadm -Cv /dev/md0 -a yes -n 3 -l 5  -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde`
   * `-x 1`：有一块作为备份盘
2. 检查磁盘阵列状态信息`mdadm -D /dev/md0`
3. 格式化：`mkfs.xfs -f /dev/md0`
4. 挂载`mount /dev/md0 /guazai/`
5. 检查挂载空间的使用情况`df -hT|grep md0`

### lvm逻辑卷管理技术

==lvm 技术它是讲一个或者多个硬盘在逻辑上进行了合并，相当于一个大的硬盘去使用，当你的硬盘空间不够了话，可以直接去其他硬盘中拿来容量去使用，这就是一个动态的盘容量管理技术==

**lvm 的使用方式**

* 基于分区形式创建lvm
  * 硬盘的多个分区，由 lvm 统一进行管理为卷组，可以弹性的调整卷组大小，加入新硬盘，可以充分的利用嵫盘容量
  * 文件系统是创建在逻辑卷上，逻辑卷可以根据需求改变大小（总容量控制在卷组中）
* 基于硬盘创建 lvm
  * 多块硬盘做成逻辑卷，将整个逻辑卷统一管理，对分区进行动态的扩容

**lvm 的常见名词**

* PP：物理分区， lvm 直接创建在物理分区之上
* PV：物理卷，处于 lvm 的最底层，一般一个 PV 对应一个 PP
* PE：物理区域， PV 中可以用于分配的最小存储单位，同一个 VG 所有的 PV 中的 PE 大小相同
* VG ：卷组，卷组创建在 PV 之上，可以划分为多个 PV
* LE：逻辑扩展单元， LE 是组成 LV 的基本单元，一个 LE 对应了一个 PE
* LV ：逻辑卷，创建在 VG 之上，是一个可以动态扩容的分区概念

**LVM 原理**

* lvm动态扩容大小，其实就是通过互相交换 PE 的过程，达到能够弹性扩容分区大小
* 想要减少空间容量 ，就是剔除 PE 的大小
* 想要扩大容量，就是把其他的 PE 添加到自己的 LV 当中
* PE 默认大小一般都是4M， LVM 最是可以创建出 65534 个 PE ，因此 LVM 最大的 VG 卷组单位是 256G
* PE 其实是 LVM 最小的存储单位，类似于操作系统的 block (4k)
* LV 逻辑卷的概念（理解为普通的分区概念， /dev/sda /dev/sdb)

**创建 lvm 的过程**

* 创建流程
  * 1物理分区阶段，针对物理磁盘或者分区，进行 fdisk 格式化，修改系统的 id ，默认是 83 ，改为 8e 类型，是 lvm 类型
  * PV 阶段，通过 pvcreate, pvdisplay 将 linux 分区改为物理卷PV
  * 创建 VG 的阶段，通过 vgcreate, vgdisplay, 将创建好的物理卷 PV 改为物理卷组 VG
  * 创建 LV ，通过 lvcreate ，将卷组，分为若干个逻辑卷
* 转化为命令操作
  * fdisk 修改磁盘的系统 id
  * pvcreate ，创建 PV ，以及显示 PV 信息 pvdisplay 也可以直接输入 pvs 查看简单的信息
  * 创建 VG 卷组， vgcreate vgs 显示卷组信息
  * 创建 lv 逻辑卷 tvcreate lvs 显示逻辑卷信息
  * 开始格式化文件系统，使用 lv 分区了
* 操作
  1. 创建pv：`pvcreate /dev/sdb /dev/sdc`
  2. 创建卷组VG：`vgcreate juanzhu /dev/sdb /dev/sdc`：创建卷组，添加物理卷
  3. 查看pv和vg信息：`pvs、vgs或pvscan、pvdisplay、vgscan、vgdisplay`
  4. 扩容或缩小：
     1. 创建物理卷：`pvcreate /dev/sdd`
     2. 加入物理卷到卷组：`vgextend juanzhu /sev/sdd`
     3. 查看pv和vg信息：`pvs、vgs或pvscan、pvdisplay、vgscan、vgdisplay`
     4. 移除卷组：`vgreduce juanzhu /dev/sdd`
     5. 删除物理卷：`pvremove /dev/sdd`
     6. 查看pv和vg信息：`pvs、vgs或pvscan、pvdisplay、vgscan、vgdisplay`
  5. 使用此时的卷组，创建逻辑卷：`lvcreate -n lv1 -L +500M luojijuan`
  6. 检查lv信息：`lvdisplay`
  7. 对luojijuan逻辑卷进行格式化：`mkfs.xfs -f /dev/juanzhu/luojijuan`
  8. 查看：`lsblk -f`
  9. 挂载
     1. 新建文件夹：`mkdir guazai`
     2. 挂载：`mount /dev/juanzhu/luojijuan guazai`
     3. 挂载到文件，开机挂载`/dev/juanzhu/luojijuan guazai xfs defaults 0 0`
     4. 读取挂载文件：`mount -a`
  10. 扩容
      1. 卸载：`umount /guazai/`
      2. 扩容现磁盘还有的空间，不是新加入磁盘：`lvextend -L +10G /dev/juanzhu/luojijuan`
      3. 挂载：`mount /dev/juanzhu/luojijuan guazai`
      4. 加载xfs大小：`xfs_groefs /dev/juanzhu/luojijuan`
      5. 检查：`df -hT`
  11. 删除逻辑卷
      1. 备份
      2. 取消挂载：`umount /guazai/`
      3. 删除逻辑卷：`lvremove /dev/juanzhu/luojijuan`
      4. 删除卷组：`vgremove /dev/juanzhu/luojijuan`
      5. 删除物理卷：`pv remove /dev/sdb /dev/sdc`
  12. 检查所有`lv、vg、pv`信息：`pvs、vgs、lvs`

## 进程管理

